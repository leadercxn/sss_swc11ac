/******************************************************************* 
 * C-file generated by Protoc for Embedded C.                      *
 * Version 0.2 (2012-01-31)                                        *
 *                                                                 *
 * Copyright (c) 2009-2012                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : LoRaMacFacCfg.proto
 * Package: 
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#include "LoRaMacFacCfg.h"

/*******************************************************************
 * Enum: LoRaMacFacCfg.proto, line 18
 *******************************************************************/
int Activation_write_with_tag(enum Activation *_Activation, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_Activation, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Enum: LoRaMacFacCfg.proto, line 23
 *******************************************************************/
int ClassType_write_with_tag(enum ClassType *_ClassType, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_ClassType, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Message: LoRaMacFacCfg.proto, line 1
 *******************************************************************/
 
void DRRagne_clear(struct DRRagne *_DRRagne) {
    _memset(_DRRagne, 0, sizeof(struct DRRagne));
}

void DRRagne_init_optional_attributes(struct DRRagne *_DRRagne) {
}

int DRRagne_is_default_message(struct DRRagne *_DRRagne) {
    return 1          && _DRRagne->_drMin == 0
         && _DRRagne->_drMax == 0
        ;
}
 
int DRRagne_write(struct DRRagne *_DRRagne, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_DRRagne->_drMin, _buffer, offset);

    offset = write_raw_varint32((2<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_DRRagne->_drMax, _buffer, offset);

    
    return offset;
}

int DRRagne_write_with_tag(struct DRRagne *_DRRagne, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = DRRagne_write_delimited_to(_DRRagne, _buffer, offset);
    
    return offset;
}

int DRRagne_write_delimited_to(struct DRRagne *_DRRagne, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = DRRagne_write(_DRRagne, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

int DRRagne_read(void *_buffer, struct DRRagne *_DRRagne, int offset, int limit) {
    unsigned int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    DRRagne_clear(_DRRagne);
    /* Assign the optional attributes. */
    DRRagne_init_optional_attributes(_DRRagne);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            /* tag of: _DRRagne._drMin */ 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _DRRagne->_drMin = tag;
                break;
            /* tag of: _DRRagne._drMax */ 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _DRRagne->_drMax = tag;
                break;
        }
    }
    
    return offset;
}

int DRRagne_read_delimited_from(void *_buffer, struct DRRagne *_DRRagne, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    DRRagne_read(_buffer, _DRRagne, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: LoRaMacFacCfg.proto, line 6
 *******************************************************************/
 
void Band_clear(struct Band *_Band) {
    _memset(_Band, 0, sizeof(struct Band));
}

void Band_init_optional_attributes(struct Band *_Band) {
}

int Band_is_default_message(struct Band *_Band) {
    return 1          && _Band->_dutyCycle == 0
         && _Band->_maxTxPower == 0
        ;
}
 
int Band_write(struct Band *_Band, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_Band->_dutyCycle, _buffer, offset);

    offset = write_raw_varint32((2<<3)+0, _buffer, offset);
    offset = write_raw_varint32(encode_zig_zag32(_Band->_maxTxPower), _buffer, offset);

    
    return offset;
}

int Band_write_with_tag(struct Band *_Band, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = Band_write_delimited_to(_Band, _buffer, offset);
    
    return offset;
}

int Band_write_delimited_to(struct Band *_Band, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = Band_write(_Band, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

int Band_read(void *_buffer, struct Band *_Band, int offset, int limit) {
    unsigned int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    Band_clear(_Band);
    /* Assign the optional attributes. */
    Band_init_optional_attributes(_Band);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            /* tag of: _Band._dutyCycle */ 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _Band->_dutyCycle = tag;
                break;
            /* tag of: _Band._maxTxPower */ 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _Band->_maxTxPower = decode_zig_zag32(tag);
                break;
        }
    }
    
    return offset;
}

int Band_read_delimited_from(void *_buffer, struct Band *_Band, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    Band_read(_buffer, _Band, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: LoRaMacFacCfg.proto, line 11
 *******************************************************************/
 
void Channel_clear(struct Channel *_Channel) {
    _memset(_Channel, 0, sizeof(struct Channel));
}

void Channel_init_optional_attributes(struct Channel *_Channel) {
    _Channel->_frequency = 0;

    DRRagne_init_optional_attributes(&_Channel->_drRange);
    _Channel->_bandIndex = 0;

}

int Channel_is_default_message(struct Channel *_Channel) {
    return 1          && _Channel->_frequency == 0
         && _Channel->_rx1Frequency == 0
         && DRRagne_is_default_message(&_Channel->_drRange)         && _Channel->_bandIndex == 0
        ;
}
 
int Channel_write(struct Channel *_Channel, void *_buffer, int offset) {
    /* Write content of each message element.*/

    /* Write the optional attribute only if it is different than the default value. */
    if(_Channel->_frequency != 0) {
        offset = write_raw_varint32((1<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_Channel->_frequency, _buffer, offset);
    }
    offset = write_raw_varint32((2<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_Channel->_rx1Frequency, _buffer, offset);

    /* Write the optional attribute only if it is different than the default value. */
    if(!DRRagne_is_default_message(&_Channel->_drRange)) {
        offset = DRRagne_write_with_tag(&_Channel->_drRange, _buffer, offset, 3);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_Channel->_bandIndex != 0) {
        offset = write_raw_varint32((4<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_Channel->_bandIndex, _buffer, offset);
    }
    
    return offset;
}

int Channel_write_with_tag(struct Channel *_Channel, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = Channel_write_delimited_to(_Channel, _buffer, offset);
    
    return offset;
}

int Channel_write_delimited_to(struct Channel *_Channel, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = Channel_write(_Channel, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

int Channel_read(void *_buffer, struct Channel *_Channel, int offset, int limit) {
    unsigned int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    Channel_clear(_Channel);
    /* Assign the optional attributes. */
    Channel_init_optional_attributes(_Channel);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            /* tag of: _Channel._frequency */ 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _Channel->_frequency = tag;
                break;
            /* tag of: _Channel._rx1Frequency */ 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _Channel->_rx1Frequency = tag;
                break;
            /* tag of: _Channel._drRange */ 
            case 3 :
                offset = DRRagne_read_delimited_from(_buffer, &_Channel->_drRange, offset);
                break;
            /* tag of: _Channel._bandIndex */ 
            case 4 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _Channel->_bandIndex = tag;
                break;
        }
    }
    
    return offset;
}

int Channel_read_delimited_from(void *_buffer, struct Channel *_Channel, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    Channel_read(_buffer, _Channel, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: LoRaMacFacCfg.proto, line 30
 *******************************************************************/
 
void FacLoRaParam_clear(struct FacLoRaParam *_FacLoRaParam) {
    _memset(_FacLoRaParam, 0, sizeof(struct FacLoRaParam));
}

void FacLoRaParam_init_optional_attributes(struct FacLoRaParam *_FacLoRaParam) {
    _FacLoRaParam->_appEUI_len = 0;

    _FacLoRaParam->_netId_len = 0;

    _FacLoRaParam->_appKey_len = 0;

    _FacLoRaParam->_nwkSKey_len = 0;

    _FacLoRaParam->_appSKey_len = 0;

    _FacLoRaParam->_appNonce_len = 0;

    _FacLoRaParam->_devNonce_len = 0;

    _FacLoRaParam->_devAddr_len = 0;

    Channel_init_optional_attributes(&_FacLoRaParam->_pingSlotChannel);
    _FacLoRaParam->_classBEnabled = 0;

    _FacLoRaParam->_pingPeriodicity = 0;

    _FacLoRaParam->_pingDataRate = 0;

    _FacLoRaParam->_beaconFrequency = 0;

    _FacLoRaParam->_beaconDataRate = 0;

    Channel_init_optional_attributes(&_FacLoRaParam->_classGChannel);
    _FacLoRaParam->_classGEnabled = 0;

    _FacLoRaParam->_classGPeriod = 0;

    _FacLoRaParam->_classGDataRate = 0;

    _FacLoRaParam->_activation = 0;

    _FacLoRaParam->_classType = 0;

}

int FacLoRaParam_is_default_message(struct FacLoRaParam *_FacLoRaParam) {
    return 1          && _FacLoRaParam->_EUI_len == 0
         && _FacLoRaParam->_appEUI_len == 0
         && _FacLoRaParam->_netId_len == 0
         && _FacLoRaParam->_appKey_len == 0
         && _FacLoRaParam->_nwkSKey_len == 0
         && _FacLoRaParam->_appSKey_len == 0
         && _FacLoRaParam->_appNonce_len == 0
         && _FacLoRaParam->_devNonce_len == 0
         && _FacLoRaParam->_devAddr_len == 0
         && _FacLoRaParam->_adr == 0
         && _FacLoRaParam->_txPower == 0
         && _FacLoRaParam->_dataRate == 0
         && _FacLoRaParam->_nbTrans == 0
         && _FacLoRaParam->_maxDutyCycle == 0
         && _FacLoRaParam->_rx1DRoffset == 0
         && _FacLoRaParam->_rx2Frequency == 0
         && _FacLoRaParam->_rx2DataRate == 0
         && _FacLoRaParam->_delay == 0
         && Channel_is_default_message(&_FacLoRaParam->_pingSlotChannel)         && _FacLoRaParam->_classBEnabled == 0
         && _FacLoRaParam->_pingPeriodicity == 0
         && _FacLoRaParam->_pingDataRate == 0
         && _FacLoRaParam->_beaconFrequency == 0
         && _FacLoRaParam->_beaconDataRate == 0
         && Channel_is_default_message(&_FacLoRaParam->_classGChannel)         && _FacLoRaParam->_classGEnabled == 0
         && _FacLoRaParam->_classGPeriod == 0
         && _FacLoRaParam->_classGDataRate == 0
         && _FacLoRaParam->_activation == 0
         && _FacLoRaParam->_classType == 0
        ;
}
 
int FacLoRaParam_write(struct FacLoRaParam *_FacLoRaParam, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+2, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_EUI_len, _buffer, offset);
    offset = write_raw_bytes(_FacLoRaParam->_EUI, _FacLoRaParam->_EUI_len, _buffer, offset);


    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_appEUI_len != 0) {
        offset = write_raw_varint32((2<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_appEUI_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_appEUI, _FacLoRaParam->_appEUI_len, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_netId_len != 0) {
        offset = write_raw_varint32((3<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_netId_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_netId, _FacLoRaParam->_netId_len, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_appKey_len != 0) {
        offset = write_raw_varint32((4<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_appKey_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_appKey, _FacLoRaParam->_appKey_len, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_nwkSKey_len != 0) {
        offset = write_raw_varint32((5<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_nwkSKey_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_nwkSKey, _FacLoRaParam->_nwkSKey_len, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_appSKey_len != 0) {
        offset = write_raw_varint32((6<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_appSKey_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_appSKey, _FacLoRaParam->_appSKey_len, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_appNonce_len != 0) {
        offset = write_raw_varint32((7<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_appNonce_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_appNonce, _FacLoRaParam->_appNonce_len, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_devNonce_len != 0) {
        offset = write_raw_varint32((8<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_devNonce_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_devNonce, _FacLoRaParam->_devNonce_len, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_devAddr_len != 0) {
        offset = write_raw_varint32((9<<3)+2, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_devAddr_len, _buffer, offset);
        offset = write_raw_bytes(_FacLoRaParam->_devAddr, _FacLoRaParam->_devAddr_len, _buffer, offset);
    }
    int channels_cnt;
    for (channels_cnt = 0; channels_cnt < _FacLoRaParam->_channels_repeated_len; ++ channels_cnt) {
        offset = Channel_write_with_tag(&_FacLoRaParam->_channels[channels_cnt], _buffer, offset, 10);
    }

    int bands_cnt;
    for (bands_cnt = 0; bands_cnt < _FacLoRaParam->_bands_repeated_len; ++ bands_cnt) {
        offset = Band_write_with_tag(&_FacLoRaParam->_bands[bands_cnt], _buffer, offset, 11);
    }

    offset = write_raw_varint32((12<<3)+0, _buffer, offset);
    offset = write_raw_byte(_FacLoRaParam->_adr, _buffer, offset);

    offset = write_raw_varint32((13<<3)+0, _buffer, offset);
    offset = write_raw_varint32(encode_zig_zag32(_FacLoRaParam->_txPower), _buffer, offset);

    offset = write_raw_varint32((14<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_dataRate, _buffer, offset);

    offset = write_raw_varint32((15<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_nbTrans, _buffer, offset);

    int channelMask_cnt;
    for (channelMask_cnt = 0; channelMask_cnt < _FacLoRaParam->_channelMask_repeated_len; ++ channelMask_cnt) {
        offset = write_raw_varint32((16<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_channelMask[channelMask_cnt], _buffer, offset);
    }

    offset = write_raw_varint32((17<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_maxDutyCycle, _buffer, offset);

    offset = write_raw_varint32((18<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_rx1DRoffset, _buffer, offset);

    offset = write_raw_varint32((19<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_rx2Frequency, _buffer, offset);

    offset = write_raw_varint32((20<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_rx2DataRate, _buffer, offset);

    offset = write_raw_varint32((21<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_FacLoRaParam->_delay, _buffer, offset);

    /* Write the optional attribute only if it is different than the default value. */
    if(!Channel_is_default_message(&_FacLoRaParam->_pingSlotChannel)) {
        offset = Channel_write_with_tag(&_FacLoRaParam->_pingSlotChannel, _buffer, offset, 22);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_classBEnabled != 0) {
        offset = write_raw_varint32((23<<3)+0, _buffer, offset);
        offset = write_raw_byte(_FacLoRaParam->_classBEnabled, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_pingPeriodicity != 0) {
        offset = write_raw_varint32((24<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_pingPeriodicity, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_pingDataRate != 0) {
        offset = write_raw_varint32((25<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_pingDataRate, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_beaconFrequency != 0) {
        offset = write_raw_varint32((26<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_beaconFrequency, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_beaconDataRate != 0) {
        offset = write_raw_varint32((27<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_beaconDataRate, _buffer, offset);
    }
    /* Write the optional attribute only if it is different than the default value. */
    if(!Channel_is_default_message(&_FacLoRaParam->_classGChannel)) {
        offset = Channel_write_with_tag(&_FacLoRaParam->_classGChannel, _buffer, offset, 28);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_classGEnabled != 0) {
        offset = write_raw_varint32((29<<3)+0, _buffer, offset);
        offset = write_raw_byte(_FacLoRaParam->_classGEnabled, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_classGPeriod != 0) {
        offset = write_raw_varint32((30<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_classGPeriod, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_classGDataRate != 0) {
        offset = write_raw_varint32((31<<3)+0, _buffer, offset);
        offset = write_raw_varint32(_FacLoRaParam->_classGDataRate, _buffer, offset);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_activation != 0) {
        offset = Activation_write_with_tag(&_FacLoRaParam->_activation, _buffer, offset, 32);
    }

    /* Write the optional attribute only if it is different than the default value. */
    if(_FacLoRaParam->_classType != 0) {
        offset = ClassType_write_with_tag(&_FacLoRaParam->_classType, _buffer, offset, 33);
    }
    
    return offset;
}

int FacLoRaParam_write_with_tag(struct FacLoRaParam *_FacLoRaParam, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = FacLoRaParam_write_delimited_to(_FacLoRaParam, _buffer, offset);
    
    return offset;
}

int FacLoRaParam_write_delimited_to(struct FacLoRaParam *_FacLoRaParam, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = FacLoRaParam_write(_FacLoRaParam, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

int FacLoRaParam_read(void *_buffer, struct FacLoRaParam *_FacLoRaParam, int offset, int limit) {
    unsigned int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    FacLoRaParam_clear(_FacLoRaParam);
    /* Assign the optional attributes. */
    FacLoRaParam_init_optional_attributes(_FacLoRaParam);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            /* tag of: _FacLoRaParam._EUI */ 
            case 1 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_EUI_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_EUI + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._appEUI */ 
            case 2 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_appEUI_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_appEUI + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._netId */ 
            case 3 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_netId_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_netId + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._appKey */ 
            case 4 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_appKey_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_appKey + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._nwkSKey */ 
            case 5 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_nwkSKey_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_nwkSKey + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._appSKey */ 
            case 6 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_appSKey_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_appSKey + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._appNonce */ 
            case 7 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_appNonce_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_appNonce + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._devNonce */ 
            case 8 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_devNonce_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_devNonce + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._devAddr */ 
            case 9 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_devAddr_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_FacLoRaParam->_devAddr + i), _buffer, offset);
                break;
            /* tag of: _FacLoRaParam._channels */ 
            case 10 :
                offset = Channel_read_delimited_from(_buffer, &_FacLoRaParam->_channels[(int)_FacLoRaParam->_channels_repeated_len++], offset);
                break;
            /* tag of: _FacLoRaParam._bands */ 
            case 11 :
                offset = Band_read_delimited_from(_buffer, &_FacLoRaParam->_bands[(int)_FacLoRaParam->_bands_repeated_len++], offset);
                break;
            /* tag of: _FacLoRaParam._adr */ 
            case 12 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_adr = tag & 1;
                break;
            /* tag of: _FacLoRaParam._txPower */ 
            case 13 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_txPower = decode_zig_zag32(tag);
                break;
            /* tag of: _FacLoRaParam._dataRate */ 
            case 14 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_dataRate = tag;
                break;
            /* tag of: _FacLoRaParam._nbTrans */ 
            case 15 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_nbTrans = tag;
                break;
            /* tag of: _FacLoRaParam._channelMask */ 
            case 16 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_channelMask[(int)_FacLoRaParam->_channelMask_repeated_len++] = tag;
                break;
            /* tag of: _FacLoRaParam._maxDutyCycle */ 
            case 17 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_maxDutyCycle = tag;
                break;
            /* tag of: _FacLoRaParam._rx1DRoffset */ 
            case 18 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_rx1DRoffset = tag;
                break;
            /* tag of: _FacLoRaParam._rx2Frequency */ 
            case 19 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_rx2Frequency = tag;
                break;
            /* tag of: _FacLoRaParam._rx2DataRate */ 
            case 20 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_rx2DataRate = tag;
                break;
            /* tag of: _FacLoRaParam._delay */ 
            case 21 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_delay = tag;
                break;
            /* tag of: _FacLoRaParam._pingSlotChannel */ 
            case 22 :
                offset = Channel_read_delimited_from(_buffer, &_FacLoRaParam->_pingSlotChannel, offset);
                break;
            /* tag of: _FacLoRaParam._classBEnabled */ 
            case 23 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_classBEnabled = tag & 1;
                break;
            /* tag of: _FacLoRaParam._pingPeriodicity */ 
            case 24 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_pingPeriodicity = tag;
                break;
            /* tag of: _FacLoRaParam._pingDataRate */ 
            case 25 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_pingDataRate = tag;
                break;
            /* tag of: _FacLoRaParam._beaconFrequency */ 
            case 26 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_beaconFrequency = tag;
                break;
            /* tag of: _FacLoRaParam._beaconDataRate */ 
            case 27 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_beaconDataRate = tag;
                break;
            /* tag of: _FacLoRaParam._classGChannel */ 
            case 28 :
                offset = Channel_read_delimited_from(_buffer, &_FacLoRaParam->_classGChannel, offset);
                break;
            /* tag of: _FacLoRaParam._classGEnabled */ 
            case 29 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_classGEnabled = tag & 1;
                break;
            /* tag of: _FacLoRaParam._classGPeriod */ 
            case 30 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_classGPeriod = tag;
                break;
            /* tag of: _FacLoRaParam._classGDataRate */ 
            case 31 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_classGDataRate = tag;
                break;
            /* tag of: _FacLoRaParam._activation */ 
            case 32 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_activation = tag;
                break;
            /* tag of: _FacLoRaParam._classType */ 
            case 33 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _FacLoRaParam->_classType = tag;
                break;
        }
    }
    
    return offset;
}

//int FacLoRaParam_read_delimited_from(void *_buffer, struct FacLoRaParam *_FacLoRaParam, int offset) {
//    unsigned long size;
//    
//    offset = read_raw_varint32(&size, _buffer, offset);
//    FacLoRaParam_read(_buffer, _FacLoRaParam, offset, size + offset);
//    
//    return offset + size;
//}

int FacLoRaParam_read_delimited_from(void *_buffer, struct FacLoRaParam *_FacLoRaParam, unsigned long size, int offset) {

    FacLoRaParam_read(_buffer, _FacLoRaParam, offset, size);
    
    return size;
}

